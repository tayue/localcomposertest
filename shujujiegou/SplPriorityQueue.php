<?php
/**
 * 而优先队列SplPriorityQueue是基于堆(后文介绍)实现的。
 */

class PQtest1 extends SplPriorityQueue
{
    public function compare($priority1, $priority2)
    {
        if ($priority1 === $priority2) return 0;
        return $priority1 < $priority2 ? -1 : 1;
    }
}

class PQtest extends SplPriorityQueue
{
    private $counter = PHP_INT_MAX;
    public function compare($priority1, $priority2)
    {
        $priorityVal1=$priority1[0];
        $priorityVal2=$priority2[0];
        if($priorityVal1!=$priorityVal2){ //如果你需要同等优先的元素来维持插入顺序，你可以使用
             return $priorityVal1 > $priorityVal2 ? 1 : -1;
        }else{
            $valCounter1=$priority1[1];
            $valCounter2=$priority2[1];
            if ($valCounter1 === $valCounter2) return 0;
            return $valCounter1 > $valCounter2 ? 1 : -1;
        }

    }

    public function insert($value, $priority)
    {
        $priorityData = [(int)$priority, $this->counter--];
        parent::insert($value, $priorityData); // TODO: Change the autogenerated stub
    }


}

$objPQ = new PQtest();

$objPQ->insert('A', 6);
$objPQ->insert('B', 6);
$objPQ->insert('C', 1);
$objPQ->insert('D', 2);
$objPQ->insert('E', 111);

echo "COUNT->" . $objPQ->count() . "<BR>";

//mode of extraction
$objPQ->setExtractFlags(PQtest::EXTR_BOTH);

//Go to TOP
$objPQ->top();

while ($objPQ->valid()) {
    print_r($objPQ->current());
    echo "<BR>";
    $objPQ->next();
}
